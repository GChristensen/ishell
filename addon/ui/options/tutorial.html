<html>
<head>
    <title>iShell Tutorial</title>
    <meta charset="utf-8">
    <link href="/ui/icons/logo.svg" rel="icon"/>
    <link rel="stylesheet" type="text/css" media="all" href="options.css"/>

    <style>
        body {
            text-align: justify;
        }

        h1 {
            color: #66bb00;
            border-top: 1px solid black;
            margin-top: 60px;
        }

        p {
            font-size: 14px;
        }
    </style>

    <script src="/lib/jquery.js"></script>
    <script src="/lib/jquery.toc.js"></script>
    <script src="rainbow/rainbow.js"></script>
    <script src="rainbow/languages/generic.js"></script>
    <script src="rainbow/languages/javascript.js"></script>
    <script src="external.js"></script>

    <link rel="stylesheet" type="text/css" media="all" href="rainbow/themes/tricolore.css"/>
</head>
<body dir="ltr">
<div style="width: 870px">

<div class="head"><span class="large">iShell: </span>Tutorial</div>
<div id="nav-container">
    <ul id="nav">
        <li><a href="options.html">Settings</a></li>
        <li><a href="commands.html">Your Commands</a></li>
        <li><a href="cmenu.html">Context Menu</a></li>
        <li><a href="edit.html">Command Editor</a></li>
        <li><a href="API.html">API Reference</a></li>
        <li class="selected"><a href="tutorial.html">Tutorial</a></li>
    </ul>
</div>

<br clear="all"/>

<div id="toc" class="toc-mobile"><h2>Contents</h2></div>
<ul data-toc></ul>


<h1 class="section-heading"><span id="The_iShell_Command_Tutorial">The iShell Command Tutorial</span></h1>

<p>The great power of iShell - from a developer standpoint - is how easy it is to create commands.
    With only a couple of lines of Javascript, it enables even casual web developers to drastically
    enhance the features of the browser. This tutorial walks you through the process of being
    generative with iShell. The original Ubiquity author tutorial, from which this one is adapted, could be found
    <a href="https://wiki.mozilla.org/Labs/Ubiquity/Ubiquity_0.5_Author_Tutorial" target="_blank">here</a>.
</p>

<p>The rest of this page documents the command development API as it is implemented in iShell. See
    <a href="API.html">iShell API Reference</a> for more details.</p>

<p>
    Note: iShell commands have access to the full browser WebExtension APIs and additionally jQuery.
    If you need some features that are not covered by the existing addon permissions,
    you need to add the necessary permissions in <code>manifest.json</code> and rebuild the addon.
</p>


<h2><span id="Real_Time_Development">Real-Time Development</span></h2>

<p>iShell doesn't require you to restart Firefox as you develop. Restarting is a drastic measure,
    and we want none of it. When you are using the built-in editor then you don't even need to save!
</p>
<p>To open the iShell command editor, summon iShell (Control+Space) and use the
    "edit-shell-commands" command.
</p>


<h2><span id="Hello_World:_The_First_Command">Hello World: The First Command</span></h2>

<h3><span id="Just_a_Message:_As_Simple_as_it_Gets">Just a Message: As Simple as it Gets</span></h3>
<p>Let's start with the standard programming trope: printing "Hello, World!".</p>
<p>In the command editor type the following:</p>

<pre><code data-language="javascript">cmdAPI.createCommand({
  names: ["say-hello"],
  execute() {
    cmdAPI.notify("Hello, World!");
  }
});</code></pre>

<p>Now try executing "say hello". You'll see that "Hello, World!" is immediately displayed
    at the bottom-right corner of the screen in a standard Firefox notification.
</p>
<p><img src="images/say-hello.png"></p>


<h3><span id="oosyntax">A Glimpse to the Modern Object-Oriented Command Syntax</span></h3>
<p>iShell allows to employ the full strength of <a
        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">JavaScript
    classes</a> in command creation. Let's rewrite the previous command in an object-oriented way.
    In this case you don't need to use <code>cmdAPI.createCommand</code>. Just declare a class with
    the <code>@command</code> annotation:</p>

<pre><code data-language="javascript">/** @command */
class SayHello {
  execute() {
    cmdAPI.notify("Hello, World!");
  }
}</code></pre>

<p>The command name will be generated automatically. Only JavaDoc-style comments may be used to
    annotate classes, the regular JavaScript comments are ignored. A command class can extend any
    other classes.</p>
<p>Object-oriented syntax also allows to significantly declutter command code, because all the noisy
    attributes you pass to the <code>cmdAPI.createCommand</code> are moved to the documentation
    comment. The class may contain only fields and functions related to its purpose. Explore
    templates in the command editor for more examples.</p>


<h3><span id="cmdAPI.createCommand">cmdAPI.createCommand</span></h3>
<p><code>cmdAPI</code> is a namespace that contains all the functions you need to create commands.
    Commands are created by making an object and passing it to <code>cmdAPI.createCommand</code>. In
    Javascript, inline curly braces stand for object literal, so this code:
</p>

<pre><code data-language="javascript">{
  names: ["say-hello"],
  execute: function () { //etc }
}</code></pre>

<p>means "Make an object with two attributes, 'names' and 'execute'." This object is then passed as
    the argument to <code>cmdAPI.createCommand</code>. 'names' and 'execute' are the only mandatory
    attributes for your command object. 'names' specifies what the command is called, and 'execute'
    specifies what it does. There are plenty of other attributes that you can specify, but they are
    all optional.<br>
</p>


<h3><span id="names">names</span></h3>
<p>'names' is always an array (thus the square brackets). In the case of this command, we provided only one
    name, "say-hello". But we could have provided as many names as we wanted. For instance, if we had
    said:
</p>

<pre><code data-language="javascript">names: ["say-hello", "greet"]</code></pre>

<p>then "say-hello" would be the normal name of the command, but iShell would also recognize "greet"
    as a synonym or alias for the command.
</p>


<h3><span id="execute">execute</span></h3>
<p>'execute' is always a function. When the user executes your command, this is the function that
    will be run. It can do pretty much anything you want - or at least, anything you know how to
    write in JavaScript.
</p>
<p>In the example above, we simply call <code>cmdAPI.notify()</code>, which displays the given
    message in whichever way the operating system can.
</p>
<p>
    There are many other useful functions in the <code>cmdAPI</code> namespace. For more
    detailed information, take a look at the <a href="API.html">iShell API Reference</a>.
</p>


<h3><span id="uuid">Command UUID</span></h3>
<p>Although any command could be run without an 'uuid' attribute, it is recommended to add it to
    every command you create. If a command is renamed, this will help to
    preserve its context menu entries, performance data, and the data the command
    stores through the Bin interface.</p>
<p>
    'uuid' may be an arbitrary unique string, for example, the homepage URL of a command. It is not
    necessary to specify 'uuid' attribute if the proper 'homepage' attribute is specified and will never change.
    An RFC 4122 v4 UUID is generated automatically for commands inserted through command editor
    templates. In the examples below we omit this attribute for brevity.
</p>


<h3><span id="Adding_a_Preview">Adding a Preview</span></h3>
<p><img src="images/preview.jpg"></p>
<p>Let's add a preview to our new command. Previews give the user feedback about what a command does
    before it's executed. Previews are great for providing rich visual feedback like displaying
    search results when using the <b>images</b> command as shown above. Previews have the full expressive
    power of HTML, including animations, so there's a lot you can do with them.
</p>
<p>One point of design: preview code should never have side effects. That is, a preview should never
    (without user interaction) change the state of the system.
</p>
<p>For the "say-hello" command, we don't need anything fancy: just some help text that is more
    descriptive than the default "Executes the say hello command."
</p>

<pre><code data-language="javascript">cmdAPI.createCommand({
  names: ["say-hello", "greet"],
  preview: "Displays a &lt;i&gt;salutary&lt;/i&gt; greeting to the planet.",
  execute() {
    cmdAPI.notify("Hello, World!");
  }
})</code></pre>

<p>Here the preview is an HTML-formatted string. The preview can also be a function. We'll get to
    that in the next section.
</p>
<h2><span id="The_Date_Command:_The_Second_Command">The Date Command: The Second Command</span>
</h2>
<h3><span id="Setting_the_Selection">Setting the Selection</span></h3>
<p>Let's create a command that inserts the current date at the location of the cursor.</p>

<pre><code data-language="javascript">cmdAPI.createCommand({
  names: ["insert-date"],
  execute() {
    cmdAPI.setSelection(new Date().toLocaleDateString());
  }
})</code></pre>

<p>The new function here is <code>setSelection()</code>. This inserts the passed-in text onto the
    page at the location of the cursor. If the cursor is in an editable text or a rich-text field,
    the text gets dumped there. If the cursor isn't in an editable area, <code>setSelection()</code>
    will still be able to insert the date. (Even when it isn't displayed, Firefox always keeps track
    of a cursor position. To see it, type F7.) Try going to a page, selecting some non-mutable text,
    and using the command. See, it works! This is particularly useful for commands like "translate",
    where you want to replace non-editable text with its translation.
</p>
<p>The <code>toLocaleDateString()</code> function is native to Javascript, so if you're not familiar
    with it check out the documentation for the Javascript <a rel="nofollow" class="external text"
    href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date">Date
    object</a>.
</p>


<h3><span id="A_Better_Preview">A Better Preview</span></h3>
<p>It's time to add a better preview to the date command. Let's have the preview show the date so
    that the user will know what to expect when they execute the command. (As a side benefit the
    user doesn't even need to execute the command to do a quick check of the day.)
</p>

<pre><code data-language="javascript">cmdAPI.createCommand({
  names: ["insert-date"],

  _date() {
    return new Date().toLocaleDateString();
  },

  preview(pblock) {
    const date = this._date();
    pblock.innerHTML = `Inserts today's date: "&lt;i&gt;${date}&lt;/i&gt;"`;
  },

  execute() {
    cmdAPI.setSelection(this._date());
  }
})</code></pre>

<p>We've done three things here. The first was to factor out the code for getting the date into the
    <code>_date()</code> function. This way we don't break <a rel="nofollow" class="external text"
                                                              href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>
    by repeating code across the preview and execute functions. Notice that to access the <code>_date()</code>,
    we use the <code>this</code> keyword.
</p>
<p>The second thing we've done is to add a preview function. The first argument is the DOM element
    that gets displayed as the preview for your command. Modify <code>pblock</code> and you modify
    the preview. In this case, we set the <code>innerHTML</code> of the preview block to be the
    message we want.
</p>
<p>The third thing we've done is the string formatting using JavaScript template literals. If some
    advanced formatting is required, there is a handy function for this: <a href="API.html#user-content-cmdutilsreducetemplate">cmdAPI.reduceTemplate()</a>,
    that is also called <code>R</code>. For example, the following code generates a nested HTML list
    from the provided array of items:
</p>

<pre>const html =
  `&lt;ul&gt;${
    R(items, item =&gt;
      `&lt;li&gt;${item.text}:
        &lt;ul&gt;
          ${R(item.subitems, subitem =&gt; `&lt;li&gt;${subitem.text}&lt;/li&gt;`)}
        &lt;/ul&gt;
      &lt;/li&gt;`)
  }&lt;/ul&gt;`;</pre>

<h3><span id="Networking_calls_and_placeholder_previews">Networking calls and placeholder previews</span>
</h3>
<p>Previews display something meaningful to the user immediately. If you have a preview that
    requires an AJAX request - say, to fetch some search results - that call might take a while to
    return. In the meantime, your command should display a placeholder preview giving the user
    feedback.
</p>

<pre><code data-language="javascript">preview: function(pblock) {
  pblock.innerHTML = "This will show until the AJAX request returns";
  cmdAPI.previewAjax(pblock, {url: "http://example.com", success: function (htm) {
    pblock.innerHTML = htm;
  }});
},</code></pre>


<!--h2><span id="Documentation_and_Metadata">Documentation and Metadata</span></h2>
<p>Before you share your command with the world, you should consider adding some attributions to the code:
</p>

<pre><code data-language="javascript">cmdAPI.createCommand({
  names: ["insert-date"],
  homepage: "http://azarask.in/",
  author: { name: "Aza Raskin", email: "aza@mozilla.com"},
  contributors: ["Atul Varma"],
  license: "MPL",

  /* THE REST OF THE CODE HERE */
})</code></pre>

<p>And you should <em>definitely</em> add some documentation:</p>

<pre><code data-language="javascript">cmdAPI.createCommand({
  names: ["insert-date"],
  homepage: "http://azarask.in/",
  author: { name: "Aza Raskin", email: "aza@mozilla.com"},
  contributors: ["Atul Varma"],
  license: "MPL",
  description: "Inserts today's date.",
  help: "If you're in an editable text area, inserts today's date, formatted for the current locale.",

  /* THE REST OF THE CODE HERE */
})</code></pre>

<p>The <code>.description</code> and <code>.help</code> attributes are both automatically displayed
    alongside your command's name on the command-list page. (The user can get to this page at any
    time by issuing the "list-shell-commands" command.) HTML tags can be used in both of these
    strings.
</p>
<p>The description is a one-line summary of what the command does, while Help is a longer description
    that can include examples, caveats, and so on. If your command is simple enough that all you
    have to say about it fits in one line, it's OK to use a description alone and leave out the
    help.
</p>

<p>In the object-oriented syntax, you put these attributes as annotations to the command
    documentation comment, except the "help" attribute. Command help will be generated from the
    entire comment text (which may contain HTML), annotations excluded.</p-->

<a id="commands-with-arguments"></a>
<h1 class="section-heading"><span id="Commands_with_Arguments">Commands with Arguments</span></h1>


<h2><span id="Echo">Echo</span></h2>
<p>Let's start by making a simple command to echo back whatever you type.</p>

<pre><code data-language="javascript">cmdAPI.createCommand({
  names: ["echo"],
  arguments: [{role: "object",
               nountype: noun_arb_text,
               label: "your shout"}],
  preview(pblock, args) {
    pblock.innerHTML = "Will echo: " + args.object.text;
  },
  execute(args) {
    const msg = args.object.text + "... " + args.object.text + "......";
    cmdAPI.notify(msg);
  },
});</code></pre>

<p>This says that the command "echo" takes one argument which is arbitrary text. Whatever text the
    user enters will get wrapped in an input object and passed into both the preview and execute
    the function.
</p>
<p>Try it! Run "echo hellooooo" and watch what happens.
</p>
<p>iShell takes care of parsing the user's input, so you don't need to worry about handling pronoun
    substitution or any of the other natural-language-like features of the iShell parser. Try
    selecting some text on a page, and run "echo this". iShell should now echo the selected text.
</p>
<p>Note that we gave three pieces of information when defining our argument: its role, its nountype,
    and its label. The label is the easiest part: It's just whatever text you want have to appear in
    the iShell interface as a prompt for the user. E.g, if you run "echo", you will see the label
    for the argument:
</p>

<pre><code data-language="javascript">echo (your shout)</code></pre>

<p>The roles and the nountypes require some more explanation. We'll cover each of them in detail
    next.
</p>
<h3><span id="Argument_Roles">Argument Roles</span></h3>
<p>Your command can take multiple arguments. Each one is identified by a "role". To understand
    roles, it helps to think of your command name as a verb, and each argument as a noun. Remember
    that iShell's command line is a pseudo-natural-language environment, so it attempts to be as
    close to natural language grammar as possible.
</p>
<p>For example, if you've ever used the <b>email</b> command, you know that it takes up to two
    arguments: a <i>message</i> and a <i>person</i>.
</p>

<pre>email message
email to person
email message to person
email to person message</pre>

<p>In grammatical terms, the <i>message</i> argument is the "direct object" of the verb "email". The <i>person</i>
    argument is an indirect object. We call it the "goal" of the verb. So if we were writing the <b>email</b>
    command, we'd define the arguments like this:
</p>

<pre><code data-language="javascript">arguments: [{role: "object",
             nountype: noun_arb_text,
             label: "message"},
            {role: "goal",
             nountype: noun_type_contact,
             label: "recipient"}]</code></pre>

<p>Because we give the recipient argument the "goal" role, the iShell parser knows to expect the
    user to type the word "to". When the user enters "email hello to user@example.com", the parser knows that the
    word following "to" - that is, "user@example.com" - should be assigned to the recipient argument.
</p>
<p>In our simple "echo" command, we expect the user to type "echo hellooooo" or something like that.
    The "hellooooo" is the direct object of the verb "echo", so we give it the "object" role.
</p>
<p>"Object" is the most common role. If a command takes only one argument, that argument is usually
    an "object".
</p>

<h4><span id="What_Roles_Can_I_Use.3F">What Roles Can I Use?</span></h4>
<ul>
    <li> object (in "echo helloooo", hello is the object.)</li>
    <li> subject (in "order flowers for Algernon", Algernon is the subject.)</li>
    <li> goal (in "email this to Brandon", Brandon is the goal.)</li>
    <li> source (in "translate this from Spanish", Spanish is the source.)</li>
    <li> location (in "yelp pizza near Boston", Boston is the location.)</li>
    <li> time (in "book a flight on thursday", thursday is the time.)</li>
    <li> instrument (in "search monkeys with Google", Google is the instrument.)</li>
    <li> format (in "check weather in Celsius", Celsius is the format.)</li>
    <li> modifier (in "get email address for Chris", Chris is the modifier.)</li>
    <li> alias (in "twitter this as Jono", Jono is the alias.)</li>
    <li> cause (in "sort lines by length", length is the cause.)</li>
    <li> dependency (in "listen song on Spotify", Spotify is the dependency.)</li>
</ul>

<h3><span id="The_Arguments_Object">The Arguments Object</span>
</h3>
<p>When your execute method is called, it is passed a single object that encapsulates the values for
    all arguments.
</p>
<p>When your preview method is called, it is passed this object, too.
</p>
<p>The object has one attribute corresponding to each role. In our example above, the command
    accepts only an object-role argument, so the preview and execute methods get passed an argument
    with an <code>args.object</code> attribute.
</p>
<p>If we made a command, like email, that takes an object-role argument and a goal-role argument,
    its preview and execute methods would get passed an argument with <code>args.object</code> and
    <code>args.goal</code>.
</p>
<p><code>args.object</code> (or <code>args.goal</code>) has several attributes of its own:
</p>

<pre><code data-language="javascript">args.object.text    // a string of the input in plain text, without formatting
args.object.html    // a string of the input in formatted HTML, including tags
args.object.data    // for non-text input types, an arbitrary data object
args.object.summary // the HTML string displayed in the suggestion list, abbreviated if long</code></pre>

<p>Our example command only cares about the <code>.text</code> attribute of the input, because it
    simply wants plain text. Often, when the user invokes your command by typing a few short words
    into the input box, <code>.text</code>, <code>.html</code>, and <code>.summary</code> will all
    have exactly the same value, and <code>.data</code> will be null. Many, if not most, commands
    that you write will only care about the text value. Nevertheless, the other versions of the
    input data are provided to you in case they differ from <code>.text</code> and in case your
    command has a use for them.
</p>

<h2><span id="Introduction_to_Noun_Types">Introduction to Noun Types</span></h2>
<p>Noun types specify what <i>kind</i> of input your command can accept for each one of its
    arguments.
</p>
<p>For the "echo" command, we wanted the object-role argument to accept any text whatsoever, so for
    its nountype we passed in the predefined <code>noun_arb_text</code> object. This object accepts
    any arbitrary text as a valid argument and passes it to the command unchanged.<br> Note:
    unexpected things may happen if a command contains more than one argument of this type.
</p>
<p><code>noun_arb_text</code> is OK for very simple commands, like echoing back the user's input. But for commands that
    take structured data, you will want to use more specific nountypes.
</p>
<p>For example, if a command can take a date, you would want to
    use <code>noun_type_date</code> as the nountype of the argument. <code>noun_type_date</code>
    provides several benefits to your command: it does all of the date parsing for you; it suggests
    dates that the user might want to enter (for instance, it defaults to today's date). And, it
    lets the parser know that your command takes a date. This is useful because when the user
    selects a date on a page and invokes iShell, your command will
    be one of the top suggestions.
</p>
<p>You can write your own noun types - we'll get into that later. For now, let's take a look at the
    built-in nountypes that your command can use. These include:
</p>

<ul>
    <li> noun_arb_text (Arbitrary text)</li>
    <li> noun_type_date (A date, in any format, or a word like "yesterday")</li>
    <li> noun_type_time (A time, in any format)</li>
    <li> noun_type_percentage (A percentage value)</li>
    <li> noun_type_email (A valid email address)</li>
    <li> noun_type_tab (One of the currently open tabs matched by title or URL)</li>
</ul>

<p><br> Once you are familiar with writing commands, you should check out the nountypes.js at the
    addon source code, which has the implementation for most of the nountypes.
</p>
<h3><span id="Regexps_as_Noun_Types">Regexps as Noun Types</span>
</h3>
<p>If none of the nountypes above is what you're looking for, there are several ways to define your
    own. The simplest is to use a regular expression. Suppose that (for whatever odd reason) you
    wanted your command to accept only arguments that begin with the letter N. The following regexp
    matches words that start with N:
</p>

<pre><code data-language="javascript">/^[nN]/</code></pre>

<p>You could use it as a noun type, like so:</p>

<pre><code data-language="javascript">arguments: [{role: "object",
             nountype: /^[nN]/,
             label: "word that starts with n"}]</code></pre>

<p>(Note that you do <i>not</i> put quotes around the regexp.)</p>
<p>A regexp nountype will reject input that doesn't match, but it doesn't know how to help the user by
    suggesting appropriate input.
</p>


<h3><span id="Lists_as_Noun_Types">Lists as Noun Types</span></h3>
<p>Suppose you're writing a command that takes a color as an argument (perhaps it outputs a
    hexadecimal RGB representation of that color.) To make a nountype that accepts colors, you can
    simply pass in an array of strings:
</p>

<pre><code data-language="javascript">names: ["convert-color"],
arguments: [{role: "object",
             nountype: ["red", "orange", "yellow", "green",
                        "blue", "violet", "black", "white",
                        "grey", "brown", "beige", "magenta",
                        "cerulean", "puce"],
             label: "color to convert"}]</code></pre>

<p>
    One benefit of specifying a list is that the parser can use it to offer the suggestions. If the
    user enters "get-color bl", for instance, iShell will be able to suggest "black" and "blue" as
    the two valid completions based on the input. This makes list-based nountypes very useful for
    any command that can accept only a finite set of values.
</p>


<h3><span id="Objects_as_Noun_Types">Objects as Noun Types</span></h3>

<p>Objects used as noun types allow to associate arbitrary data with the argument input value. Let's
    imagine that you want to create a command that offers a choice between some options represented
    by API parameters, that you do not want show to the user.</p>

<pre><code data-language="javascript">names: ["call-api-with"],
arguments: [{role: "object",
             nountype: {"option1": "api-parameter-1",
                        "option2": "api-parameter-2",
                        "option3": "api-parameter-3"}
             label: "option"}]</code></pre>

<p>Although "option1", "option2"... will be shown to the user and stored in <code>args.object.text</code>,
    in the command handler methods you can access the actual values of the corresponding API parameters
    using the <code>args.object.data</code> property.</p>


<h3><span id="Writing_a_Noun_Type_Object">Creating Custom Noun Types</span></h3>
<p>Of course, not every type of noun you'd be interested in can be represented as a finite list or
    as a regexp. If you want to be able to accept or reject input based on some algorithmic test,
    you can do so by writing a custom JavaScript object that implements a <code>suggest()</code>
    method (and, optionally, a <code>default()</code> method.)
</p>
<p>There is an example of how to do this in the section on the tab commands below.</p>


<h2><span id="Insert_Email:_the_Contact_noun_type">Insert Email: the Contact noun type</span></h2>
<p>Let's take a look at one of the built-in nountypes: <code>noun_type_contact</code>. By using this
    nountype, iShell will be able to autocomplete the known emails while the user is entering the command.
    <code>noun_type_contact</code> is what the built-in iShell command "email" uses. At the moment, iShell figures out what
    the known emails are just by remembering arguments you have ever passed to the <b>email</b> or <b>compose</b>
    commands.
</p>
<p>The following command lets you insert someone's email address using autocompletion.
</p>

<pre><code data-language="javascript">cmdAPI.createCommand({
  name: "insert-email",
  arguments: [{role: "modifier", nountype: noun_type_contact}],
  preview: "Inserts someone's email address.",
  execute(args) {
    cmdAPI.setSelection(args.modifier.html);
  },
});</code></pre>

<p>To try this out, execute "insert-email of " and then the first few letters of address someone you mailed
    earlier through the commands mentioned above.
</p>

<h1 class="section-heading"><span id="Search_Commands">Creating Search Commands</span></h1>
    <p>Because Web is volatile, iShell contains search commands only for the essential sites and
        services, but you can easily make your own with the <a href="API.html#make-search-command"
                                                               target="_blank">cmdAPI.makeSearchCommand()</a>
        function. It can automatically parse both HTML and JSON content and also accepts custom
        filter functions to process DOM of the requested page with jQuery. Let's make a function that
        performs search at <a href="http://urbandictionary.org">urbandictionalry.org</a>:</p>

<pre><code data-language="javascript">cmdAPI.makeSearchCommand({
    name: "urban",
    uuid: "261DF55D-5E22-4E5F-8A81-6ED31B81AE3E",
    url: "https://www.urbandictionary.com/define.php?term=%s",
    defaultUrl: "https://www.urbandictionary.com",
    arguments: [{role: "object", nountype: noun_arb_text, label: "query"}],
    icon: "https://www.urbandictionary.com/favicon.ico",
    previewDelay: 1000,
    parser: {
        type      : "html",
        container : ".definition",
        title     : "h1 a",
        href      : "h1 a",
        body      : container => {
            const meaning = container.find(".meaning");
            meaning.css("border-bottom", "1px solid white");
            meaning.css("margin-bottom", "5px");
            const example = container.find(".example");
            example.css("font-style", "italic");
            return $("&lt;div&gt;").append(meaning).append(example);
        }
    }
});</code></pre>


<!--h3><span id="Shorter_Argument_Declarations">Shorter Argument Declarations</span></h3>

<p>In the code above we used a shortcut for declaring the arguments. In the long-form, we would have had
    to say:
</p>

<pre><code data-language="javascript">arguments: [{role: "modifier",
             nountype: noun_type_contact,
             label: "contact"}]</code></pre>

<p>But if we don't care about specifying extra parameters for the argument, we can get away with
    using a single object for "arguments", with the roles as the property names, and the nountypes
    as the property values:
</p>

<pre><code data-language="javascript">arguments: {modifier: noun_type_contact}</code></pre>

<p>or with label using <code>"_"</code> (or <code>" "</code>) as separator:
</p>

<pre><code data-language="javascript">arguments: {modifier_contact: noun_type_contact}</code></pre>

<p>Note: in the object-oriented syntax it is not necessary to use argument roles anyway.</p>

<p>If we had several arguments, we could say:</p>

<pre><code data-language="javascript">arguments: {object: noun_arb_text, modifier: noun_type_contact}</code></pre>

<p>Finally, if you only have "object" and don't need to specify a label...:
</p>

<pre><code data-language="javascript">argument: noun_arb_text</code></pre>

<p>iShell increases the surface area of innovation for the browser many-fold, by making anyone who
    can write simple Javascript into an agent for bettering the browser and the open Web.
</p-->

<h1><span id="oosyntax_revisited">Object-oriented Syntax Revisited</span></h1>

<p>Now you know more about commands and arguments, so we can create a more complex object-oriented
    command with arguments. Let's call it <code>show-text</code>. It has the following syntax:
    <b>show-text</b> <i>message text</i> <b>in</b> <i>destination</i>.</p>

<pre><code data-language="javascript">/**
  Displays a given message at a popup or prints it to the browser log.

  @command show-text, display-text
  @description An object-oriented command with arguments.
*/
class ShowTextCommandClass {
  constructor(args) {
    args[OBJECT] = {nountype: noun_arb_text, label: "message"};
    args[IN]     = {nountype: ["popup", "log"], label: "destination"};
  }

  preview(args, display, storage) {
    if (args[OBJECT]?.text) {
      const msg = `Shows &lt;i&gt;${args[OBJECT]?.text}&lt;/i&gt; in &lt;b&gt;${args[IN]?.text || "popup"}&lt;/b&gt;`;
      display.set(msg);
    }
    else
      this.previewDefault(display);
  }

  execute(args, storage) {
    const destination = args[IN]?.text;
    const message = args[OBJECT]?.text;

    if (destination === "log")
      console.log(message);
    else
      cmdAPI.notify(message);
  }
}</code></pre>

<p>Let's see what happens here.</p>
<p>The <code>@command</code> annotation allows to override the command name generated by default.
    The content of the documentation comment above the class (except annotations) is displayed at
    the help section of iShell command listing. It may contain HTML or <a
            href="https://en.wikipedia.org/wiki/Markdown" target="_blank">markdown</a>-formatted
    text if the <code>@markdown</code> annotation is used.</code></p>

<p><code>show-text</code> defines a nameless arbitrary text <b>object</b> argument in its
    constructor, along with an argument named <b>in</b> that can take two values:
    <i>popup</i> and <i>log</i>. These values will be available to the autocompletion.</p>

<p>With the object-oriented syntax you do not need to remember obscure argument roles and just
    directly use the names of arguments when defining them in the constructor or accessing them in
    methods (although you may access arguments in the old way if you prefer). Please do not use the
    command constructor for any purposes other than argument definition and simple field
    initialization, since iShell may create the command object multiple times for various reasons.
    There are <a href="#Running_on_iShell_load_and_when_iShell_popup_is_shown_">several other
        functions</a> that are used to initialize commands.
</p>

<p>You may also notice that object-oriented methods have the <code>args</code> argument always in
    the first position, and <code>pblock</code> argument is now called <code>display</code>. It
    still contains a reference to the same <code>div</code> element of iShell preview area but has
    a new nice <code>set</code> method that sets element's innerHTML property for you. <code>storage</code>
    argument is a reference to the <a href="API.html#user-content-bin">Bin interface</a> of the
    command.</p>


<h2><span id="metaclass">The @metaclass Annotation</span></h2>

<p>Classes annotated with the <code>@metaclass</code> annotation do not automatically create
    commands. Instead, they could be instantiated and passed to <code>cmdAPI.createCommand</code>,
    or be inherited from. This is convenient when it is necessary to create a command-generating
    function like <code>cmdAPI.createSearchCommand</code>, which produces commands that contain the
    same logic but differ slightly in some aspects. In the example below, <code>createSuffixCommand</code>
    function uses a metaclass to generate a set of such commands.
</p>

<pre><code data-language="javascript">/**
  This class does not create any commands automatically.

  @command
  @metaclass
  @description Supplies input with the "%s" suffix.
*/
class SuffixCommand {
  suffix = "";

  constructor(args) {
    args[OBJECT] = {nountype: noun_arb_text, label: "input"};
  }

  // a method named metaconstructor is used to initialize instances
  // of the command
  metaconstructor(options) {
    Object.assign(this, options);

    // note that in the metaconstructor it is possible to process attributes
    // placed in the comment above the command
    this.description = this.description.replace("%s", this.suffix);
  }

  preview({OBJECT}, display) {
    if (OBJECT?.text)
      display.text(`Processed input: ${OBJECT?.text}${this.suffix}`);
    else
      this.previewDefault(display);
  }

  execute() {}
}

function createSuffixCommand(options) {
  // command constructor takes the same arguments as its
  // metaconstructor method
  cmdAPI.createCommand(new SuffixCommand(options));
}

createSuffixCommand({name: "um-suffix", suffix: "um", uuid: "uuid1"});
createSuffixCommand({name: "issa-suffix", suffix: "issa", uuid: "uuid2"});</code></pre>

<p>Here we use <code>display.text</code> method instead of <code>display.set</code> to change the
    contents of the preview. <code>display.text</code> adds the same margins to the output, as the ones
    iShell uses to display command description, so the output does not wiggle as in the previous command.
</p>


<h1><span id="TinyURL:_Network_Calls_and_jQuery">TinyURL: Network Calls and jQuery</span></h1>

<p>Often while writing emails, we'll discover that we've pasted in a URL long enough to be used for
    unfortunate analogies. We'd like to be able to quickly turn that into a <a rel="nofollow"
                                                                              class="external text"
                                                                              href="http://en.wikipedia.org/wiki/Tinyurl">TinyURL</a>
    - but the process of making a TinyURL involves lots of fiddly steps. iShell to the rescue.
</p>
<p>Because we include <a rel="nofollow" class="external text"
                         href="http://en.wikipedia.org/wiki/jQuery">jQuery</a> with iShell, it is
    simple to perform Ajax calls as well as parse returning data. TinyUrl.com provides an easy to
    use RESTful API where you pass a URL and it returns its shortened form. We use that API in this
    command.
</p>

<pre><code data-language="javascript">/** @command
    @description Replaces the selected URL with a TinyUrl.
*/
class Tinyurl {
  constructor(args) {
    args[OBJECT] = {nountype: noun_arb_text, label: "url to shorten"};
  }
  execute({OBJECT: {text: userUrl}}) {
    const apiUrl = "http://tinyurl.com/api-create.php";
    jQuery.get(apiUrl, {url: userUrl}, tinyUrl => cmdAPI.setSelection(tinyUrl));
  }
}</code></pre>

<p>jQuery is a powerful tool. With it, you can fairly effortlessly cherry-pick the data you need
    from RSS feeds, XML, and all sorts of other data formats. It also makes doing in-preview
    animations a breeze.
</p>

<h1 class="section-heading"><span id="Using_Browser_APIs">Executing Content Scripts</span></h1>
<p>Content scripts allow to modify or retrieve items of the live document loaded into a browser
    tab. Use the <a href="API.html#user-content-executescript" target="_blank">cmdAPI.executeScript()</a>
    function to run JavaScript code in the context of the tab document. For an
    example, let's create a command that changes the color of the heading tags
    (for example, H1 or H2) and prints the text of each heading in the preview area.</p>

<pre><code data-language="javascript">/**
 Executes content scripts in the active tab

 # Examples
 - change-color **of** *H2* **to** *red*

 @command
 @markdown
 @description Changes the color of the given heading tags.
*/
class ChangeColor {
  constructor(args) {
    args[OF] = {nountype: ["H1", "H2", "H3", "H4", "H5"], label: "selector"};
    args[TO] = {nountype: ["red", "green", "blue"], label: "color"};
  }

  async preview({OF}, display) {
    await this.injectJQuery();

    // a function with its arguments should be passed to executeScript
    // this works both in MV2 and MV3
    // do not pass references to class methods
    const [{result}] = await cmdAPI.executeScript({func: extractHeadings, args: [OF.text]});
    const headingList = `<ul>${
      R(result, h => (`<li>${h}</li>`))
    }</ul>`;

    display.set(headingList)
  }

  async execute({OF, TO}) {
    await this.injectJQuery();
    await cmdAPI.executeScript({func: colorHeadings, args: [OF.text, TO.text]});
  }

  async injectJQuery() {
    const hasJQuery = await cmdAPI.executeScript({func: () => !!window.$});

    // inject jQuery bundled with the add-on
    if (!hasJQuery[0]?.result)
      await cmdAPI.executeScript({file: "/lib/jquery.js"});
  }
}

// these functions are executed as content scripts in the context of the tab document

function extractHeadings(selector) {
  const headings = $(selector).map((_, element) => element.textContent);
  return Array.from(headings);
}

function colorHeadings(selector, color) {
  $(selector).css("color", color);
}</code></pre>

<h1 class="section-heading"><span id="Persistent_Storage">Persistent Storage</span></h1>
<p>Some commands may want to store data that persist even after closing Firefox.
    Meet the <a href="API.html#user-content-bin" target="_blank">Bin</a> interface. Note the use of
    <a href="API.html#user-content-previewlist" target="_blank">cmdAPI.previewList()</a> function to create
    a list with clickable items.
</p>

<pre><code data-language="javascript">/**
 @command
 @delay 1000
 @description Lets you jot a memo for the page.
 @uuid FA6A3460-E825-4CFA-A24F-5908131D29FD
*/
class Memo {
  constructor(args) {
    args[OBJECT] = {nountype: noun_arb_text, label: "text"};
  }

  preview(_, display, Bin) {
    const href = cmdAPI.getLocation();
    const list = Bin[href]();

    if (!list) {
      display.text(`No memos taken for: <small><code>${href}</code></small>`);
      return;
    }

    let ol = cmdAPI.previewList(display, list, function deleteMemo(i, ev) {
      $(ev.target).closest("li").slideUp();
      list.splice(i, 1);
      Bin[href](list.length ? list : null);
      gId = +new Date;
    });

    ol.setAttribute("data-id", gId);
  }

  execute({object: {html}}, Bin) {
    const href = cmdAPI.getLocation();
    const list = Bin[href]() || [];

    list.push(html);
    Bin[href](list);
    this.ID = +new Date;
  }
}</code></pre>


<h1 class="section-heading"><span id="Switching_Tabs">Switching Tabs: Creating Custom Noun Types</span></h1>

<p>The last command in this tutorial is for switching between tabs. The end goal is this: type a
    few characters that match the title of an open tab (in any window), hit return, and you've
    switched to that tab.
</p>
<p>We'll write this command in two steps. The first step is creating a tab nountype. The second
    step is using that nountype to create the tab-switching command.
</p>


<h3><span id="Switching_Tabs:_Writing_your_own_Noun-Types">Switching Tabs: Writing your own Noun-Types</span>
</h3>
<p>A nountype needs to only have two things: A <code>label</code> and a <code>suggest()</code>
    function. It can optionally also have a <code>default()</code> function.
</p>
<p>The label is what shows up when the command prompts for input. Suggest returns a list of input
    objects, each one containing the name of a matching tab.
</p>

<pre><code data-language="javascript">const noun_type_browser_tab = {
  label: "tab title or URL",

  async _searchTabs(text, maxResults) {
    const matcher = new RegExp(text, "i");
    const tabs = await browser.tabs.query({});
    const results = tabs.filter(tab => {
      tab.__match = matcher.exec(tab.title) || matcher.exec(tab.url);
      return !!tab.__match;
    });

    return results.slice(0, maxResults)
  },

  // suggestion methods declared as async do not need to use callback
  async suggest(text, html, callback, selectedIndices) {
    const tabs = await this._searchTabs(text, 5);
    const makeSugg = tab => cmdAPI.makeSugg(tab.title || tab.url, null, tab,
                                            cmdAPI.matchScore(tab.__match),
                                            selectedIndices);
    return tabs.map(makeSugg);
  }
};</code></pre>

<p>The suggest method of a noun type always gets passed both text and html. If the input is coming
    from a part of a web page that the user has selected, these values can be different: they are
    both strings, but the html value contains markup tags while the text value does not. The Tab
    noun type only cares about the plain text of the tab name, so we ignore the value of html.
</p>
<p>The callback argument is for use by nountypes that need to run asynchronously, i.e. because they
    need to do network calls to generate suggestions. The callback is a function; instead of
    returning a list of suggestions right away, an asynchronous noun type can call the callback with
    each suggestion it generates.
</p>
<p>We use the convenience function <code>cmdAPI.makeSugg()</code> to generate an input object of the
    type that the iShell parser expects. The full signature of this function is:
</p>

<pre><code data-language="javascript">cmdAPI.makeSugg(text, html, data, score, selectionIndices);</code></pre>

<p>It requires at least one of <code>text</code>, <code>html</code>, <code>data</code>. Use <code>null</code>
    if you want to skip <code>text</code> and/or <code>html</code>.
</p>
<p>If the text or html input is very long, <code>makeSugg()</code> generates a summary for us and
    puts it in the <code>summary</code> attribute of the input object.
</p>
<p>We could have accomplished mostly the same thing without calling <code>makeSugg()</code> by
    returning a list of anonymous objects like these:
</p>

<pre><code data-language="javascript">{ text: tabName,
  html: Utils.escapeHtml(tabName),
  data: tab,
  summary: Utils.escapeHtml(tabName) };</code></pre>

<p>The input objects that our <code>suggest()</code> method generates are the same objects that will
    eventually get passed into the <code>execute()</code> and <code>preview()</code> methods of any
    commands that use this noun type.
</p>

<h3><span id="generating_nountypes_with_annotations">Generating Noun Types with Annotations</span></h3>

<p>If your noun type needs nothing more than <code>suggest</code> function, you may apply <code>@nountype</code>
    annotation to a regular function to generate the noun type with the same name:</p>

<pre><code data-language="javascript">/** @nountype
    @label foo
*/
function noun_type_foo(text, html, callback, selectedIndices) {
    // ...
}</code></pre>

<p>The annotated function accepts the same arguments as the <code>suggest</code> function of a
    full-fledged noun type.
</p>

<h3><span id="Switching_Tabs:_The_Command">Switching Tabs: The Command</span></h3>
<p>Now that we are armed with the tab nountype, it is easy to make the tab-switching command.
</p>

<pre><code data-language="javascript">/** @command
    @description Switches to the tab with the given title.
*/
class SwitchTab {
  constructor(args) {
    args[OBJECT] = {nountype: noun_type_browser_tab};
  }
  preview({OBJECT: {text: tabName}}, display) {
    if (tabName)
      display.text(`Changes to <strong>${tabName}</strong> tab.`);
    else
      display.text(`Switch to a tab by name.`);
  }
  execute({OBJECT: {data: tab}}) {
    browser.tabs.update(tab?.id, {active: true});
  }
}</code></pre>

<h1 class="section-heading"><span id="Development_Hints">Development Hints</span></h1>

<p>You now know all you need to know to get started developing useful iShell commands of your own.
</p>
<p>Here are some miscellaneous tips that didn't fit elsewhere on this page, that may make
    development easier for you.
</p>

<h2 id="helper"><span>Helper Application</span></h2>
<p>The helper application that could be installed along with iShell is a local web server that
    may be used to transcend the limits of WebExtensions. Because dynamic code execution is forbidden
    in WebExtensions manifest v3, the helper application is the only way to compile user commands
    in MV3 version of iShell.
    </p>

<p>If you installed the helper application as a Python package, you may develop your own
    <a href="https://flask.palletsprojects.com/en/2.1.x/" target="_blank">Flask</a> handlers
    callable from user commands. There you could do anything what Python can.
    Although technically you may make requests to any
    local web server, the lifetime of the helper application is managed automatically by the browser.
    Use the <a href="API.html#helper-fetch" target="_blank">cmdAPI.helperFetch()</a>
    function to call helper application handlers.
</p>

<h2><span id="Running_on_page_load.2C_iShell_load_and_startup">Running Code on iShell load and when iShell popup is shown</span></h2>
<p>There are two additional command properties that may be set in cmdAPI.createCommand for that purposes:</p>
<ul>
    <li><b>load</b> - a function, called exactly once when iShell is loaded.</li>
    <li><b>init</b> - a function, called each time iShell popup is shown with the popup document
        as the parameter. Any document-wide CSS/script injections should be performed here.
    </li>
</ul>

<h2><span id="Anaphora">Anaphora</span></h2>
<p>If there is an active selection, and the value of an <i>arbitrary text argument</i> is equal to one of the
    predefined <a href="https://en.wikipedia.org/wiki/Anaphora_(linguistics)" target="_blank">anaphoric</a>
    pronouns, the command handler methods will receive the content of the selection through this
    argument. In the following example, the pronoun <b>this</b> will be substituted for the content of
    the active selection at the current page:<br><br>
    &nbsp;&nbsp;<b>send</b> <b>this</b> <b>to</b> <i>user@example.com</i> <b>with</b> <i>subject
        text</i><br><br> This may be useful if the command contains more than one <i>arbitrary text
    argument</i>, so it is possible to specify any value of the second such argument in the command line
    (the <b>with</b> argument in the example above). Without anaphoric pronouns, all text after the
    first space in the value of the second <i>arbitrary text argument</i> will be assigned to
    the first such one, which is always the <code>object</code>. If there is no active selection,
    anaphoric pronouns are treated as literal text values.
</p>
<p>iShell parser recognizes the following anaphoric pronouns:</p>
<ul>
    <li>this</li>
    <li>that</li>
    <li>it</li>
    <li>selection</li>
    <li>him</li>
    <li>her</li>
    <li>them</li>
</ul>

<h2><span id="Ace_Code_Editor">Ace Code Editor</span></h2>
<p>iShell uses <a href="https://ace.c9.io/" target="_blank">Ace</a> code editor to edit user-defined
    commands. It is worth getting familiar with its <a
            href="https://github.com/ajaxorg/ace/wiki/Default-Keyboard-Shortcuts" target="_blank">keyboard
        shortcuts</a>. The most often used ones are: <code>Ctrl-F</code> - find, <code>Ctrl-H</code>
    - replace, <code>Ctrl-,</code> (Ctrl and comma) - open editor settings panel. An additional
    nonstandard shortcut: <code>Ctrl-S</code> will immediately evaluate and save the edited code.
</p>

<hr>
<p>Authors: Aza Raskin, Blair McBride, Abimanyu Raja, Jono DiCarlo, Atul Varma, Gerrard Christensen</p>

</div>
</body>
</html>