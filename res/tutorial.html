<html xmlns="http://www.w3.org/1999/xhtml" style="cursor: auto ! important;" hasBrowserHandlers="true">
<head>
    <title>iShell Tutorial</title>
    <meta charset="utf-8">
    <link href="/res/icons/logo.svg" rel="icon"/>
    <link rel="stylesheet" type="text/css" media="all" href="options.css"/>

    <style>
        body {
            text-align: justify;
        }

        h1 {
            color: #66bb00;
            border-top: 1px solid black;
            margin-top: 60px;
        }

        p {
            font-size: 14px;
        }
    </style>

    <script src="/lib/jquery.js"></script>
    <script src="/lib/jquery.toc.js"></script>
</head>
<body dir="ltr">
<div class="head"><span class="large">iShelliShell: </span>Tutorial</div>
<div id="nav-container">
    <ul id="nav">
        <li><a href="options.html">Settings</a></li>
        <li><a href="commands.html">Your Commands</a></li>
        <li><a href="cmenu.html">Context Menu</a></li>
        <li><a href="edit.html">Command Editor</a></li>
        <li><a href="API.html">API Reference</a></li>
        <li class="selected"><a href="tutorial.html">Tutorial</a></li>
    </ul>
</div>

<br clear="all"/>

<div id="mw-mf-viewport">
    <nav id="mw-mf-page-left" class="navigation-drawer view-border-box">

    </nav>
    <div id="mw-mf-page-center">

            <div id="toc" class="toc-mobile"><h2>Contents</h2></div>
            <ul data-toc>

            </ul>
        </div>
        <h1 class="section-heading">
            <span class="mw-headline"
                  id="The_iShell_Command_Tutorial">The iShell Command Tutorial</span>
        </h1>
        <div class="mf-section-1">
            <p>The great power of iShell - from a developer standpoint - is how easy it is to create commands. With
                only a
                couple of lines of Javascript, it enables even casual web developers to drastically enhance the
                features of the browser. This tutorial walks you through the process of being generative with
                iShell.
            </p>
            <p>The rest of this page documents the command developer API which is implemented in iShell. See the
                <a href="API.html">iShell API Reference</a>.
            <p>
                Note: iShell commands have access to the full browser WebExtension API and additionally jQuery.
                But you may still need to add necessary permissions in manifest.json and rebuild the
                addon if you need some features that are not covered by the existing addon permissions.
            </p>
            </p>
            <h2 class="in-block"><span class="mw-headline" id="Real_Time_Development">Real Time Development</span></h2>
            <p>iShell doesn't require you to restart Firefox as you develop. Restarting is a drastic measure, and we
                want none of it. Instead, iShell reloads the commands every time it is summoned. When you are using
                the built-in editor then you don't even need to save!
            </p>
            <p>To open the iShell command editor, summon iShell (Control+Space) and use the "edit-shell-commands"
                command.
            </p>
            <h2 class="in-block"><span class="mw-headline" id="Hello_World:_The_First_Command">Hello World: The First Command</span>
            </h2>
            <h3 class="in-block"><span class="mw-headline" id="Just_a_Message:_As_Simple_as_it_Gets">Just a Message: As Simple as it Gets</span>
            </h3>
            <p>Let's start with the standard programing trope: printing "Hello, World!".
            </p>
            <p>In the command editor type the following:
            </p>
            <pre>
cmdAPI.createCommand({
  names: ["say-hello"],
  uuid: "http://example.com/say-hello",
  execute: function hello_execute() {
    cmdAPI.notify("Hello, World!");
  }
});
</pre>
            <p>Now try executing "say hello". You'll see that "Hello, World!" is immediately displayed on the screen. If
                you are on Mac OSX with <a rel="nofollow" class="external text"
                                           href="http://en.wikipedia.org/wiki/Growl_(software)">Growl</a> installed the
                message will appear as a Growl notification. If you are on Windows, then it will appears as a standard
                "toaster" notification in the bottom right-hand corner of the screen.
            </p>
            <p><img src="images/say-hello.png">
            </p>

            <h3 class="in-block"><span class="mw-headline" id="oosyntax">A glimpse to the modern object-oriented command syntax</span>
            </h3>
            <p>iShell allows to employ the full strength of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes">JavaScript classes</a>
                in command creation. Let's rewrite the
                previous command in the object-oriented way. To accomplish this you don't need to use <code>cmdAPI.createCommand</code>.
            Just declare a class:</p>

            <pre>
/**
   @uuid http://example.com/say-hello
*/
class SayHello {
  execute() {
    cmdAPI.notify("Hello, World!");
  }
}
</pre>
            <p>The name will be generated automatically. iShell will interpret any class in the command editor as a command,
                unless its name starts with an underscore,
                or it contains <code>@noncommand</code> annotation at the documentation comment above. Regular JavaScript comments are ignored.
                Non-command classes may be used to for subclassing, bringing common functionality to multiple commands.</p>
            <p>Object-oriented syntax also allows to significantly declutter the command code, because all noisy attributes are moved to the documentation
            comment and command class may only contain fields and functions related to its purpose. Explore templates in the command editor for more details.</p>

            <h3 class="in-block"><span class="mw-headline" id="cmdAPI.createCommand">cmdAPI.createCommand</span>
            </h3>
            <p><code>cmdAPI</code> is a namespace which contains all the functions you need to create commands.
                Commands are created by making an object and passing it to <code>cmdAPI.createCommand</code>. In
                Javascript, inline curly braces stands for object literal, so this code:
            </p>
            <pre>
{
  names: ["say-hello"],
  uuid: "http://example.com/say-hello",
  execute: function () { //etc }
}
</pre>
            <p>means "Make an object with three attributes, 'names', 'uuid' and 'execute'." This object is then passed as the
                argument to <code>cmdAPI.createCommand</code>.
                'names', 'uuid' and 'execute' are the only mandatory attributes for your command object. 'names' specifies
                what the command is called, 'uuid' - is a globally (presumably) unique identifier of the command, and 'execute'
                specifies what it does. There are plenty of other attributes that you can specify, but they are all optional.<br>
            </p>
            <h3 class="in-block"><span class="mw-headline" id="names">names</span></h3>
            <p>'names' is always an array (thus the square brackets). In the case of this command we provided only one
                name, "hello world". But we could have provided as many names as we wanted. For instance, if we had
                said:
            </p>
            <pre> names: ["say-hello", "greet"]
</pre>
            <p>then "say-hello" would be the normal name of the command, but iShell would also recognize "greet" as a
                synonym or alias for the command.
            </p>

            <h3 class="in-block"><span class="mw-headline" id="uuid">uuid</span></h3>
            <p> 'uuid' may be an arbitrary unique string, for example, the homepage URL of a command.
            An RFC 4122 v4 complaint UUID is generated
            automatically for commands added through command editor templates. In the examples below we omit this
            attribute for brevity.
            </p>

            <h3 class="in-block"><span class="mw-headline" id="execute">execute</span></h3>
            <p>'execute' is always a function. When the user executes your command, this is the function that will be
                run. It can do pretty much anything you want - or at least, anything you know how to write in
                JavaScript.
            </p>
            <p>In the example above, we simply call <code>cmdAPI.notify()</code>, which displays the given message in
                whichever way the operating system can.
            </p>
            <p><br>
                There are a number of other useful functions in the <code>cmdAPI</code> namespace. For
                more detailed information, take a look at the <a href="API.html">iShell API Reference</a>.
            </p>

            <!--h3 class="in-block"><span class="mw-headline" id="Making_sure_your_command_is_localizable">Making sure your command is localizable</span>
            </h3>
            <p>iShell command parser supports multiple languages. That means that hopefully someday someone will be
                translating
                your commands to the other languages that iShell supports. There is currently no command localization
                support
                in iShell, although you may take measures in the case it will appear someday.
                You just have to locate all strings that appear in your
                <code>preview()</code> and <code>execute()</code> methods, that are intended for display to humans, and
                wrap them with:
            </p>
            <pre>_()
</pre>
            <p>This may look odd, but what it does is quite important: it makes your strings appear in the template
                files that localizers will be using. So let's make our "Hello world!" command localizable:
            </p>
            <pre>
cmdAPI.createCommand({
  names: ["say-hello", "greet"],
  execute: function hello_execute() {
    cmdAPI.notify(_("Hello, World!"));
  }
});
</pre>
            <p>Note that we don't need to wrap the names, or other strings that appear in the command metadata - these
                are automatically wrapped for us. We only need to wrap strings that appear inside the functions.
            </p-->
            <h3 class="in-block"><span class="mw-headline" id="Adding_a_Preview">Adding a Preview</span></h3>
            <p><img src="images/preview.jpg"></p>
            <p>Let's add a preview to our new command. Previews give the user feedback about what a command does before
                it's executed. Previews are great for providing rich visual feedback like displaying search results when
                using the images command as shown above. Previews have
                the full expressive power of HTML, including animations, so there's a lot you can do with them.
            </p>
            <p>One point of design: Preview code should never have side-effects. That is, a preview should never
                (without user interaction) change the state of the system.
            </p>
            <p>For the "say-hello" command, we don't need anything fancy: just some help text that is more descriptive
                than the default "Executes the say hello command."
            </p>
            <pre>
cmdAPI.createCommand({
  names: ["say-hello", "greet"],
  preview: "Displays a &lt;i&gt;salutary&lt;/i&gt; greeting to the planet.",
  execute: function hello_execute() {
    cmdAPI.notify("Hello, World!");
  }
})
</pre>
            <p>Here the preview is an HTML-formatted string. The preview can also be a function. We'll get to that in
                the next section.
            </p>
            <h2 class="in-block"><span class="mw-headline" id="The_Date_Command:_The_Second_Command">The Date Command: The Second Command</span>
            </h2>
            <h3 class="in-block"><span class="mw-headline" id="Setting_the_Selection">Setting the Selection</span></h3>
            <p>I often forget what day it is. That may be because I need to go outside more often, but, like any
                programmer, I generally solve my problem's symptoms with technology rather then addressing the root
                cause. My solution is to create a command that inserts the date at the location of the cursor.
            </p>
            <pre>
cmdAPI.createCommand({
  names: ["insert-date"],
  execute: function date_execute() {
    cmdAPI.setSelection(new Date().toLocaleDateString());
  }
})
</pre>
            <p>The new function here is <code>setSelection()</code>. This inserts the passed-in text onto the page at
                the location of the cursor. If the cursor is in an editable text or rich-text fields, the text gets
                dumped there. If the cursor isn't in an editable area, <code>setSelection()</code> will still be able to
                insert the date. (Even when it isn't displayed, Firefox always keeps track of a cursor position. To see
                it, type F7.) Try going to a page, selecting some non-mutable text, and using the command. See, it
                works! This is particularly useful for commands like "translate", where you want to replace non-editable
                text with its translation.
            </p>
            <p>The <code>toLocaleDateString()</code> function is native to Javascript, so if you're not familiar with it
                check out the documentation for the Javascript <a rel="nofollow" class="external text"
                                                                  href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Date">Date
                    object</a>.
            </p>
            <h3 class="in-block"><span class="mw-headline" id="A_Better_Preview">A Better Preview</span></h3>
            <p>It's time to add a better preview to the date command. Let's have the preview show the date, so that the
                user will know what to expect when they execute the command. (As a side benefit the user doesn't even
                need to execute the command to do a quick check of the day.)
            </p>
            <pre>
cmdAPI.createCommand({
  names: ["insert-date"],

  _date: function date__date() {
    return new Date().toLocaleDateString();
  },

  preview: function date_preview(pblock) {
    var msg = _('Inserts today\'s date: "&lt;i&gt;${date}&lt;/i&gt;"');
    pblock.innerHTML = cmdAPI.renderTemplate(msg, {date: this._date()});
  },

  execute: function date_execute() {
    cmdAPI.setSelection(this._date());
  }
})
</pre>
            <p>We've done three things here. The first was to factor out the code for getting the date into the <code>_date()</code>
                function. This way we don't break <a rel="nofollow" class="external text"
                                                     href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>
                by repeating code across the preview and execute functions. Notice that to access the
                <code>_date()</code>, we use the <code>this</code> keyword.
            </p>
            <p>The second thing we've done is to add a preview function. The first argument is the DOM element that gets
                displayed as the preview for your command. Modify <code>pblock</code> and you modify the preview. In
                this case, we set the <code>innerHTML</code> of the preview block to be the message we want.
            </p>
            <p>The third thing we've done is to do some string formatting using the <code>renderTemplate()</code>
                function. This takes a template string and performs the appropriate substitution given the passed-in
                JSON object. Templates can handle a wide range of functionality, as we are currently using TrimPath's <a
                        rel="nofollow" class="external text"
                        href="http://code.google.com/p/trimpath/wiki/JavaScriptTemplates">JavascriptTemplates</a>.
                Although JavascriptTemplates has some nice features, such as ${for}, in the most cases it is more
                convenient to use ES6 template literals (``) nowadays.
            </p>
            <h3 class="in-block"><span class="mw-headline" id="A_shortcut_for_localization_and_rendering_templates">A shortcut for localization and rendering templates</span>
            </h3>
            <p>Note how in the code above, we used the localization wrapper <code>_()</code> before passing the string
                to renderTemplate. Because this is such a very common combination when displaying strings, we have a
                shortcut for it. Calling _() with a JSON object as the second argument will automatically trigger <code>cmdAPI.renderTemplate()</code>
                on the post-localization string. So the above preview method could be rewritten more simply as:
            </p>
            <pre>
  preview: function date_preview(pblock) {
    var msg = 'Inserts today's date: "&lt;i&gt;${date}&lt;/i&gt;"';
    pblock.innerHTML = _(msg, {date: this._date()});
  },
</pre>
            <h3 class="in-block"><span class="mw-headline" id="Networking_calls_and_placeholder_previews">Networking calls and placeholder previews</span>
            </h3>
            <p>Previews display something meaningful to the user immediately. If you have a preview that requires an
                AJAX request - say, to fetch some search results - that call might take a while to return. In the
                meantime,
                your command should display a placeholder preview giving the user feedback.
            </p>
            <pre>
  preview: function(pblock) {
    pblock.innerHTML = "This will show until the AJAX request returns";
    cmdAPI.previewAjax(pblock, "http://example.com", function (htm) {
      pblock.innerHTML = htm;
    });
  },
</pre>
            <h2 class="in-block"><span class="mw-headline"
                                       id="Documentation_and_Metadata">Documentation and Metadata</span></h2>
            <p>Before you share your command with the world, you should consider adding some attributions to the code:
            </p>
            <pre>
cmdAPI.createCommand({
  names: ["insert-date"],
  homepage: "http://azarask.in/",
  author: { name: "Aza Raskin", email: "aza@mozilla.com"},
  contributors: ["Atul Varma"],
  license: "MPL",

  /* THE REST OF THE CODE HERE */
})
</pre>
            <p>And you should <em>definitely</em> add some documentation:
            </p>
            <pre>
cmdAPI.createCommand({
  names: ["insert-date"],
  homepage: "http://azarask.in/",
  author: { name: "Aza Raskin", email: "aza@mozilla.com"},
  contributors: ["Atul Varma"],
  license: "MPL",
  description: "Inserts today's date.",
  help: "If you're in an editable text area, inserts today's date, formatted for the current locale.",

  /* THE REST OF THE CODE HERE */
})
</pre>
            <p>The <code>.description</code> and <code>.help</code> attributes are both automatically displayed
                alongside your command's name on the command-list page. (The user can get to this page at any time by
                issuing the "list-shell-commands" command.) HTML tags can be used in both of these strings.
            </p>
            <p>Description is a one-line summary of what the command does, while Help is a longer description that can
                include examples, caveats, and so on. If your command is simple enough that all you have to say about it
                fits in one line, it's OK to use a description alone and leave out the help.
            </p>

            <p>In the object-oriented syntax you put these attributes as annotations to the command documentation comment, except
            the "help" attribute. Command help will be generated from the entire comment text (which may contain HTML), annotations excluded.</p>

            <!--
                        <h2 class="in-block"><span class="mw-headline" id="Map_Me.21_Location.2C_Snapshots.2C_and_Inserting_HTML">Map Me! Location, Snapshots, and Inserting HTML</span>
                        </h2>
                        <p>The "map" command that comes with iShell is fairly powerful. It's also fairly complicated—well,
                            comparatively. It's still only a couple hundred lines of code. The command, though, can get even more
                            useful. Imagine being able to select some houses on Craigslist, or a list of restaurant names, and run
                            "map these" to get just the map you want. The concept of "these" puts the power of mashups into the
                            users hands. But I digress. Let's make a simple command that inserts a map of your current location.
                        </p>
                        <p>In this command, we use the Google <a rel="nofollow" class="external text"
                                                                 href="http://code.google.com/apis/maps/documentation/staticmaps/">static
                            map API</a> and the iShell function <code>cmdAPI.getGeoLocation()</code> to insert a map of your
                            current location. iShell currently uses the <a rel="nofollow" class="external text"
                                                                             href="http://www.maxmind.com/app/api">MaxMind</a> API
                            for trying to guess your location from your IP. That will probably change in the future.
                        </p>
                        <p>We'll call this command <code>"map me"</code> so that it won't be confused with the standard
                            <code>"map"</code> command.
                        </p>
                        <pre>
            cmdAPI.createCommand({
              names: ["map me"],

              _getMapUrl: function() {
                var loc = cmdAPI.getGeoLocation();
                var mapUrl = "http://maps.google.com/staticmap?";

                var params = {
                  center: loc.lat + "," + loc.long,
                  size: "500x400",
                  zoom: 14,
                  key: "ABQIAAAAGZ11mh1LzgQ8-8LRW3wEShQeSuJunOpTb3RsLsk00-MAdzxmXhQoiCd940lo0KlfQM5PeNYEPLW-3w"
                };

                return mapUrl + jQuery.param( params );
              },

              preview: function( pblock ) {
                var msg = "Inserts a map of your current location: &lt;br/&gt;" +
                          "&lt;img src='${url}'/&gt;";
                pblock.innerHTML = _(msg, {url: this._getMapUrl()});
              },

              execute: function( ) {
                cmdAPI.getImageSnapshot( this._getMapUrl(), function(imgData) {
                  cmdAPI.setSelection( "&lt;img src='" + imgData +"'/&gt;");
                })
              }
            })
            </pre>
                        <p>There are three new things here: <code>cmdAPI.setSelection</code> to set HTML (yep, it can do that);
                            the use of <code>cmdAPI.getGeoLocation()</code>; and using <code>cmdAPI.snapshotImage()</code> to
                            capture the bits for the image.
                        </p>
                        <p>I find getting the location—as imprecise as IP-based location can be—useful for doing sensible defaults
                            for location-based commands, like Yelp. <code>cmdAPI.getGeoLocation()</code> returns an object which
                            has the following properties: city, state, country, lat, and long.
                        </p>
                        <p>Why do we need to use <code>cmdAPI.snapshotImage()</code>? Because the Google Maps API requires a key
                            that is tied to a particular URL. If we naively inject the image tag into a random web page, the image
                            won't load because the key doesn't match that random web page's URL. Thus, we use the <code>snapshotImage()</code>
                            function to convert the image into a <a rel="nofollow" class="external text"
                                                                    href="http://en.wikipedia.org/wiki/Data:_URI_scheme">data
                                url</a>.
                        </p>
                        <p>There's also a <code>cmdAPI.snapshotWindow</code> function, which allows you to get the image data for
                            any tab/window. The function takes a window as the first paramater, and a callback for the second.
                        </p>
                    </div>
            -->
            <a id="commands-with-arguments"></a>
            <h1 class="section-heading">
                <div class="mw-ui-icon mw-ui-icon-element indicator"></div>
                <span class="mw-headline" id="Commands_with_Arguments">Commands with Arguments</span></h1>
            <div class="mf-section-2">
                <h2 class="in-block"><span class="mw-headline" id="Echo">Echo</span></h2>
                <p>Let's start by making a simple command to echo back whatever you type.
                </p>
                <pre>
cmdAPI.createCommand({
  names: ["echo"],
  arguments: [{role: "object",
               nountype: noun_arb_text,
               label: "your shout"}],
  preview: function previewEcho(pblock, args) {
    pblock.innerHTML = "Will echo: " + args.object.text;
  },
  execute: function executeEcho(args) {
    var msg = args.object.text + "... " + args.object.text + "......";
    cmdAPI.notify(msg);
  },
});
</pre>
                <p>This says that the command "echo" takes one argument which is arbitrary text. Whatever text the user
                    enters will get wrapped in an input object and passed into both the preview and execute function.
                </p>
                <p>Try it! Run "echo hellooooo" and watch what happens.
                </p>
                <p>iShell takes care of parsing the user's input, so you don't need to worry about handling prounoun
                    substitution or any of the other natural-language-like features of the iShell parser. Try
                    selecting
                    some text on a page, and run "echo this". iShell should now echo the selected text.
                </p>
                <p>Note that we gave three pieces of information when defining our argument: its role, its nountype, and
                    its
                    label. The label is the easiest part: It's just whatever text you want to have appear in the
                    iShell
                    interface as a prompt for the user. E.g, if you run "echo", you will see the label for the
                    argument:
                </p>
                <pre>
  echo (your shout)
</pre>
                <p>The roles and the nountypes require some more explanation. We'll cover each of them in detail next.
                </p>
                <h3 class="in-block"><span class="mw-headline" id="Argument_Roles">Argument Roles</span></h3>
                <p>Your command can take multiple arguments. Each one is identified by a "role". To understand roles, it
                    helps to think of your command name as a verb, and each argument as a noun. Remember that iShell's
                    command line is a pseudo-natural-language environment, so it attempts to be as close to natural
                    language
                    grammar as possible.
                </p>
                <p>For example, if you've ever used the <code>email</code> command, you know that it takes up to two
                    arguments: a message and a person.
                </p>
                <pre>
  email message
  email to person
  email message to person
  email to person message
</pre>
                <p>In grammatical terms, the message argument is the "direct object" of the verb "email". The person
                    argument is an indirect object. We call it the "goal" of the verb. So if we were writing the email
                    command, we'd define the arguments like this:
                </p>
                <pre>
  arguments: [{role: "object",
               nountype: noun_arb_text,
               label: "message"},
              {role: "goal",
               nountype: noun_type_contact,
               label: "recipient"}]
</pre>
                <p>Because we give the recipient argument the "goal" role, the iShell parser knows to expect the user
                    to
                    type the word "to". When the user enters "email hello to Aza", the parser knows that the word
                    following
                    "to" - that is, "Aza" - should be assigned to the recipient argument.
                </p>
                <p>In our simple "echo" command, we expect the user to type "echo hellooooo" or something like that. The
                    "hellooooo" is the direct object of the verb "echo", so we give it the "object" role.
                </p>
                <p>"Object" is the most common role. If a command takes only one argument, that argument is usually an
                    "object".
                </p>
                <h4 class="in-block"><span class="mw-headline" id="What_Roles_Can_I_Use.3F">What Roles Can I Use?</span>
                </h4>
                <ul>
                    <li> object (in "echo helloooo", hello is the object.)</li>
                    <li> subject (in "flowers for Algernon", Algernon is the subject.)</li>
                    <li> goal (in "email this to Brandon", Brandon is the goal.)</li>
                    <li> source (in "translate this from spanish", spanish is the source.)</li>
                    <li> location (in "yelp pizza near boston", boston is the location.)</li>
                    <li> time (in "book a flight on thursday", thursday is the time.)</li>
                    <li> instrument (in "search monkeys with google", google is the instrument.)</li>
                    <li> format (in "check weather in celsius", celsius is the format.)</li>
                    <li> modifier (in "get email address for chris", chris is the modifier.)</li>
                    <li> alias (in "twitter this as jono", jono is the alias.)</li>
                    <li> cause (in "pleased by appearance", appearance is the cause.)</li>
                    <li> dependency (in "smoke on the water", the water is the dependency.)</li>
                </ul>

                <h3 class="in-block"><span class="mw-headline" id="The_Arguments_Object">The Arguments Object</span>
                </h3>
                <p>When your execute method is called, it is passed a single object that encapsulates the values for all
                    arguments.
                </p>
                <p>When your preview method is called, it is passed this object, too.
                </p>
                <p>The object has one attribute corresponding to each role. In our example above, the command accepts
                    only
                    an object-role argument, so the preview and execute methods get passed an argument with an <code>args.object</code>
                    attribute.
                </p>
                <p>If we made a command, like email, that takes an object-role argument and a goal-role argument, its
                    preview and execute methods would get passed an argument with <code>args.object</code> and <code>args.goal</code>.
                </p>
                <p><code>args.object</code> (or <code>args.goal</code>) has several attributes of its own:
                </p>
                <pre>
  args.object.text    // a string of the input in plain text, without formatting
  args.object.html    // a string of the input in formatted HTML, including tags
  args.object.data    // for non-text input types, an arbitrary data object
  args.object.summary // the HTML string displayed in the suggestion list, abbreviated if long
</pre>
                <p>Our example command only cares about the <code>.text</code> attribute of the input, because it simply
                    wants plain text. Often, when the user invokes your command by typing a few short words into the
                    input
                    box, <code>.text</code>, <code>.html</code>, and <code>.summary</code> will all have exactly the
                    same
                    value, and <code>.data</code> will be null. Many, if not most, commands that you write will only
                    care
                    about the text value. Nevertheless, the other versions of the input data are provided to you in case
                    they differ from <code>.text</code> and in case your command has a use for them.
                </p>

                <h2 class="in-block"><span class="mw-headline"
                                           id="oosyntax_revisited">Object-oriented Syntax Revisited</span></h2>

                <p>Now you know more about commands and arguments, so we can create a more complex object-oriented command with arguments.
                    Let's call it <code>show-text</code>. It will have the following syntax: <b>show-text</b> <i>message text</i> <b>in</b> <i>destination</i>.</p>
<pre>
/**
  Displays a given message at popup or prints it to the browser log.

  @description An object-oriented command with arguments.
*/
class ShowText {
  constructor(args) {
    args[OBJECT] = {nountype: noun_arb_text, label: "message"};
    args[IN]     = {nountype: ["popup", "log"], label: "destination"};
  }

  preview(args, display) {
      let html = `Shows &lt;i&gt;${args[OBJECT]?.text}&lt;/i&gt; in &lt;b&gt;${args[IN]?.text || "popup"}&lt;/b&gt;`;
      display.set(html);
  }

  execute(args) {
    let destination = args[IN]?.text;
    let message = args[OBJECT]?.text;

    if (destination === "log")
      console.log(message);
    else
      cmdAPI.notify(message);
  }
}
</pre>
<p>The content of the documentation comment above the class (except annotations) is displayed at the help section of the iShell command listing.
    The command defines a nameless object argument in its constructor, along with a prepositional argument <b>in</b> which can take two values: <i>popup</i> and <i>log</i>. These values will
    be available to autocompletion. With the object-oriented syntax you do not need to remember obscure argument role names and just use the names
    of arguments themselves when defining them in the constructor or accessing in methods (although you may access them in the old way if you prefer).
    Please do not use the command constructor for any purposes other than argument definition, since iShell may create the command object multiple times for various reasons.
    There are <a href="#Running_on_iShell_load_and_when_iShell_popup_is_shown_">several other functions</a> for command initialization.
</p>
                <p>You may also notice that object-oriented methods have the <code>args</code> argument always in the first position,
                    and <code>pblock</code> argument is now called <code>display</code>. It still contains a reference to the same <code>div</code> element
                of iShell preview area, but has a new nice <code>set</code> method which sets element's innerHTML property for you.</p>

                <h2 class="in-block"><span class="mw-headline"
                                           id="Introduction_to_Noun_Types">Introduction to Noun Types</span></h2>
                <p>Noun types specify what <i>kind</i> of input your command can accept for each one of its arguments.
                </p>
                <p>For the "echo" command, we wanted the object-role argument to accept any text whatsoever, so for its
                    nountype we passed in the predefined <code>noun_arb_text</code> object. This object accepts any
                    arbitrary text as a valid argument and passes it to the command unchanged.<br>
                    Note: unexpected things may happen if a command contains more than one argument of this type.
                </p>
                <p>This is OK for very simple commands, like echoing back the user's input. But for commands that take
                    structured data, you will want to use more specific nountypes.
                </p>
                <p>For example, if a command can take a date (like the "check calendar" command), you would want to use
                    <code>noun_type_date</code> as the nountype of the argument. <code>noun_type_date</code> provides
                    several benefits to your command: it does all of the date parsing for you; it suggests dates that
                    the
                    user might want to enter (for instance, it defaults to today's date). And, it lets the parser know
                    that
                    your command takes a date. This is useful because when the user selects a date on a page and invokes
                    iShell, your command - along with "check calendar" - will be one of the top suggestions.
                </p>
                <p>You can write your own noun types - we'll get into that later. For now, let's take a look at the
                    built-in nountypes that your command can use. These include:
                </p>
                <ul>
                    <li> noun_arb_text (Arbitrary text)</li>
                    <li> noun_type_date (A date, in any format, or a word like "tomorrow")</li>
                    <li> noun_type_time (A time, in any format)</li>
                    <li> noun_type_percentage (A percentage value)</li>
                    <li> noun_type_email (A valid email address)</li>
                    <li> noun_type_tab (One of currently open tabs matched by title or URL)</li>
                </ul>
                <p><br>
                    Once you are familiar with writing commands, you should check out the nountypes.js at the addon source code,
                    which has the implementation for most of the noun-types.
                </p>
                <h3 class="in-block"><span class="mw-headline" id="Regexps_as_Noun_Types">Regexps as Noun Types</span>
                </h3>
                <p>If none of the nountypes above is what you're looking for, there are several ways to define your own.
                    The
                    simplest is to use a regular expression. Suppose that (for whatever odd reason) you wanted your
                    command
                    to accept only arguments that begin with the letter N. The following regexp matches words that start
                    with N:
                </p>
                <pre>
  /^[nN]/
</pre>
                <p>You could use it as a noun type, like so:
                </p>
                <pre>
  arguments: [{role: "object",
               nountype: /^[nN]/,
               label: "word that starts with n"}]
</pre>
                <p>(Note that you do <i>not</i> put quotes around the regexp.)
                </p>
                <p>A regexp nountype will reject input that doesn't match, but it doesn't know how to help the user by
                    suggesting appropriate input.
                </p>
                <h3 class="in-block"><span class="mw-headline" id="Lists_as_Noun_Types">Lists as Noun Types</span></h3>
                <p>Suppose you're writing a command that takes a color as an argument (perhaps it outputs a hexadecimal
                    RGB
                    representation of that color.) To make a nountype that accepts colors, you can simply pass in an
                    array
                    of strings:
                </p>
                <pre>
  names: ["convert-color"],
  arguments: [{role: "object",
               nountype: ["red", "orange", "yellow", "green",
                          "blue", "violet", "black", "white",
                          "grey", "brown", "beige", "magenta",
                          "cerulean", "puce"],
               label: "color to convert"}]
</pre>
                <p><br>
                    One benefit of using a list is that the parser can use it offer the user suggestions. If the user
                    enters
                    "get-color bl", for instance, iShell will be able to suggest "black" and "blue" as the two valid
                    completions based on the input. This makes list-based nountypes very useful for any command that can
                    accept only a finite set of values.
                </p>
                <h3 class="in-block"><span class="mw-headline"
                                           id="Writing_a_Noun_Type_Object">Writing a Noun Type Object</span></h3>
                <p>Of course, not every type of noun you'd be interested in can be represented
                    as a finite list or as a regexp. If you want to be able to accept or reject input based on some
                    algorithmic test, you can do so by writing a custom JavaScript object that implements a
                    <code>suggest()</code> method (and, optionally, a <code>default()</code> method.)
                </p>
                <p>There is an example of how to do this in the section on the tab commands, below.
                </p>
                <h2 class="in-block"><span class="mw-headline" id="Insert_Email:_the_Contact_noun_type">Insert Email: the Contact noun type</span>
                </h2>
                <p>Let's take a look at one of the built-in noun-types: <code>noun_type_contact</code>. By using the
                    noun-type, iShell will also
                    autocomplete to known people while the user is entering the command. This is what the built-in
                    iShell
                    command "email" uses. At the moment, iShell figures out what people you know just by remembering
                    emails you have ever passed
                    to the <b>email</b> or <b>compose</b> commands.
                </p>
                <p>Enough rambling. It's time for a command. I constantly find that I need to fetch someone's email
                    address
                    to paste into a text field because I don't know it off-hand. This command solves that by letting you
                    insert someone's email address using autocomplete.
                </p>
                <pre>
cmdAPI.createCommand({
  name: "insert-email",
  arguments: {modifier: noun_type_contact},
  preview: "Inserts someone's email address by name.",
  execute: function(args) {
    cmdAPI.setSelection(args.modifier.html);
  },
});
</pre>
                <p>To try this out, execute "insert-email of " and then the first few letters of someone you mailed through
                    the commands mentioned above.
                </p>
                <h3 class="in-block"><span class="mw-headline" id="Shorter_Argument_Declarations">Shorter Argument Declarations</span>
                </h3>
                <p>Notice that we used a shortcut for declaring the arguments. In the long form, we would have had to
                    say:
                </p>
                <pre>
  arguments: [{role: "modifier",
               nountype: noun_type_contact,
               label: "contact"}]
</pre>
                <p>but if we don't care about specifying extra parameters for the argument, we can get away with using a
                    single object for "arguments", with the roles as the property names, and the nountypes as the
                    property
                    values:
                </p>
                <pre>
  arguments: {modifier: noun_type_contact}
</pre>
                <p>or with label using <code>"_"</code> (or <code>" "</code>) as separator:
                </p>
                <pre>
  arguments: {modifier_contact: noun_type_contact}
</pre>
                <p>If we had several arguments, we could say:
                </p>
                <pre>
  arguments: {object: noun_arb_text, modifier: noun_type_contact}
</pre>
                <p>Finally, if you only have "object" and don't need to specify a label...:
                </p>
                <pre>
  argument: noun_arb_text
</pre>

                    <p>iShell increases the surface area of innovation for the browser many-fold, by making anyone who
                        can
                        write simple Javascript into an agent for bettering the browser and the open Web.
                    </p>

                <h2 class="in-block"><span class="mw-headline"
                                           id="TinyURL:_Network_Calls_and_jQuery_.28and_the_URL_noun_type.29">TinyURL: Network Calls and jQuery</span>
                </h2>
                <p>Often while writing emails, I'll discover that I've pasted in a URL long enough to be used for
                    unfortunate analogies. I'd like to be able to quickly turn that into a <a rel="nofollow"
                                                                                              class="external text"
                                                                                              href="http://en.wikipedia.org/wiki/Tinyurl">TinyURL</a>
                    - but
                    the process of making a TinyURL involves lots of fiddly steps. iShell to the rescue.
                </p>
                <p>Because we include <a rel="nofollow" class="external text"
                                         href="http://en.wikipedia.org/wiki/jQuery">jQuery</a>
                    with iShell, it is simple to perform Ajax calls as well as parse returning data. TinyUrl.com
                    provides
                    an easy to use RESTful API where you pass a URL and it returns its shortened form. We use that API
                    in
                    this command.
                </p>
                <pre>
cmdAPI.createCommand({
  names: ["tinyurl"],
  description: "Replaces the selected URL with a TinyUrl.",
  arguments: [{role: "object",
               nountype: noun_arb_text,
               label: "url to shorten"}],
  execute: function(args) {
    var baseUrl = "http://tinyurl.com/api-create.php";
    var params = {url: args.object.text};
    jQuery.get(baseUrl, params, function(tinyUrl) {
      cmdAPI.setSelection(tinyUrl);
    });
  },
})
</pre>
                <p>jQuery is a powerful tool. With it, you can fairly effortlessly cherry-pick the data you need from
                    RSS
                    feeds, XML, and all sorts of other data formats. It also makes doing in-preview animations a breeze.
                </p>
            </div>

            <!--
                    <h1 class="section-heading">
                        <div class="mw-ui-icon mw-ui-icon-element indicator"></div>
                        <span class="mw-headline" id="Twitter:_Putting_It_All_Together">Twitter: Putting It All Together</span></h1>
                    <div class="mf-section-3">
                        <p>We've now covered everything we need to cover in order to write a command that allows us to <a
                                rel="nofollow" class="external text" href="http://en.wikipedia.org/wiki/Twitter">Twitter</a> from
                            iShell. The code below is the actual source code of the Twitter command as it appears in iShell 0.5.
                        </p>
                        <p>Many thanks to <a rel="nofollow" class="external text"
                                             href="http://theunfocused.net/moz/iShell/verbs/">Blair McBride</a> for writing this
                            command. The source code is a bit more intricate than anything we've seen so far, but it's built using
                            exactly the same basic pieces - and demonstrates nearly all of those pieces in action.
                        </p>
                        <pre>
            const TWITTER_STATUS_MAXLEN = 140;

            cmdAPI.createCommand({
              names: ["twitter", "tweet", "share using twitter"],
              arguments: [
                {role: "object", label: 'status', nountype: noun_arb_text},
                {role: "alias", nountype: noun_type_twitter_user}
              ],
              icon: "http://twitter.com/favicon.ico",
              description:
              "Sets your Twitter status to a message of at most 160 characters.",
              help: ("You'll need a &lt;a href=\"http://twitter.com\"&gt;Twitter account&lt;/a&gt;," +
                     " obviously.  If you're not already logged in" +
                     " you'll be asked to log in."),
              preview: function(previewBlock, args) {
                var statusText = (args.object ? args.object.text : '');
                var usernameText = "";
                if (args.alias) {
                  usernameText = args.alias.text;
                } else if (args.as) {
                  usernameText = args.as.text;
                }
                var previewTemplate = (
                  "&lt;div class='twitter'&gt;"+_("Updates your Twitter status ${username} to:")+"&lt;br/&gt;" +
                  "&lt;b class='status'&gt;${status}&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;" +
                  _("Characters remaining: &lt;b&gt;${chars}&lt;/b&gt;") +
                  "&lt;p&gt;&lt;small&gt;"+_("tip: tweet @mozillaiShell for help")+"&lt;/small&gt;&lt;/p&gt;&lt;/div&gt;");
                var truncateTemplate = (
                  "&lt;strong&gt;"+_("The last &lt;b&gt;${truncate}&lt;/b&gt; characters will be truncated!")+"&lt;/strong&gt;");
                var previewData = {
                  status: &lt;&gt;{statusText}&lt;/&gt;.toXMLString(),
                  username: usernameText &amp;&amp; _("(For user &lt;b&gt;${usernameText}&lt;/b&gt;)"),
                  chars: TWITTER_STATUS_MAXLEN - statusText.length
                };

                var previewHTML = cmdAPI.renderTemplate(
                                    cmdAPI.renderTemplate(previewTemplate, previewData),
                                    {usernameText:usernameText});

                if (previewData.chars &lt; 0) {
                  var truncateData = {
                    truncate: 0 - previewData.chars
                  };

                  previewHTML += cmdAPI.renderTemplate(truncateTemplate, truncateData);
                }

                previewBlock.innerHTML = previewHTML;
              },
              execute: function(args) {
                var statusText = args.object.text;
                if(statusText.length &lt; 1) {
                  this._show(_("requires a status to be entered"));
                  return;
                }

                var updateUrl = "https://twitter.com/statuses/update.json";
                var updateParams = {
                  source: "iShell",
                  status: statusText
                  //dont cut the input since sometimes, the user selects a big url,
                  //and the total lenght is more than 140, but tinyurl takes care of that
                };
                var me = this;

                function sendMessage() {
                  jQuery.ajax({
                    type: "POST",
                    url: updateUrl,
                    data: updateParams,
                    dataType: "json",
                    error: function() {
                      me._show(_("error - status not updated"));
                    },
                    success: function() {
                      me._show(/^d /.test(statusText)
                               ? _("direct message sent")
                               : _("status updated"));
                    },
                    username: login.username,
                    password: login.password
                  });
                }

                var login;
                var alias = args.alias;
                if (alias &amp;&amp; alias.text &amp;&amp; alias.data) {
                  login = alias.data;
                  sendMessage();
                } else {
                  login = {username: null,
                           password: null};
                  if (alias &amp;&amp; alias.text)
                    login.username = alias.text;
                  sendMessage();
                }
              },
              _show: function(txt){
                cmdAPI.notify({icon: this.icon, title: this.name, text: txt});
              }
            });
            </pre>
                    </div>
            -->
            <h1 class="section-heading">
                <div class="mw-ui-icon mw-ui-icon-element indicator"></div>
                <span class="mw-headline" id="Switching_Tabs">Switching Tabs</span></h1>
            <div class="mf-section-4">
                <p>The final command in this tutorial is for switching between tabs. The end goal is this: type a few
                    keys
                    to that matches the title of an open tab (in any window), hit return, and you've switched to that
                    tab.
                </p>
                <p>We'll write this command in two steps. The first step is creating a tab noun-type. The second step is
                    using that noun-type to create the tab-switching command.
                </p>
                <h3 class="in-block"><span class="mw-headline" id="Switching_Tabs:_Writing_your_own_Noun-Types">Switching Tabs: Writing your own Noun-Types</span>
                </h3>
                <p>A noun-type needs to only have two things: A <code>label</code> and a <code>suggest()</code>
                    function. It
                    can optionally also have a <code>default()</code> function.
                </p>
                <p>The label is what shows up when the command prompts for input. Suggest returns a list of input
                    objects,
                    each one containing the name of a matching tab.
                </p>
                <pre>
var noun_type_browser_tab = {
    label: "tab title or URL",
    _searchTabs(text, maxResults, callback) {
        let matcher = new RegExp(text, "i");

        chrome.tabs.query({}, tabs => {
            let results = [];
            for (let tab of tabs) {
                let match = matcher.exec(tab.title) || matcher.exec(tab.url);
                if (!match) continue;
                tab.match = match;
                results.push(tab);
                if (maxResults && results.length >= maxResults) break;
            }
            callback(results);
        });
    },
    suggest: function(text, html, callback, selectedIndices) {
        this._searchTabs(text, 5, tabs => {
            callback(tabs.map(tab =>
                cmdAPI.makeSugg(
                    tab.title || tab.url,
                    null, tab, cmdAPI.matchScore(tab.match), selectedIndices)));
        });

        return []; // normally, we should return suggestions here, but our noun type is asynchronous
    }
};
</pre>
                <p>The suggest method of a noun type always gets passed both text and html. If the input is coming from
                    a
                    part of a web page that the user has selected, these
                    values can be different: they are both strings, but the html value contains markup tags while the
                    text
                    value does not. The Tab noun type only cares about the plain text of the tab name, so we ignore the
                    value of html.
                </p>
                <p>The callback argument is for use by nountypes that need to run asynchronously, i.e. because they need
                    to
                    do network calls to generate suggestions. The callback is a function; instead of returning a list of
                    suggestions right away, an asynchronous noun type can call the callback with each suggestion it
                    generates.
                </p>
                <p>We use the convenience function <code>cmdAPI.makeSugg()</code> to generate an
                    input object of the type that the iShell parser expects. The full signature of this function is:
                </p>
                <pre>
cmdAPI.makeSugg(text, html, data, score, selectionIndices);
</pre>
                <p>It requires at least one of <code>text</code>, <code>html</code>, <code>data</code>. Use
                    <code>null</code> if you want to skip <code>text</code> and/or <code>html</code>.
                </p>
                <p>If the text or html input is very long, <code>makeSugg()</code> generates a summary for us, and puts
                    it
                    in the <code>summary</code> attribute of the input object.
                </p>
                <p>We could have accomplished mostly the same thing without calling <code>makeSugg()</code> by returning
                    a
                    list of anonymous objects like these:
                </p>
                <pre>
{ text: tabName,
  html: Utils.escapeHtml(tabName),
  data: tab,
  summary: Utils.escapeHtml(tabName) };
</pre>
                <p>The input objects that our <code>suggest()</code> method generates are the same objects that will
                    eventually get passed in to the <code>execute()</code> and <code>preview()</code> methods of any
                    commands that use this noun type.
                </p>
                <h3 class="in-block"><span class="mw-headline"
                                           id="Switching_Tabs:_The_Command">Switching Tabs: The Command</span></h3>
                <p>Now that we are armed with the tab noun-type, it is easy to make the tab-switching command. Again, we
                    use
                    FUEL to focus the selected tab.
                </p>
                <pre>
cmdAPI.createCommand({
  names: ["switch-tab"],
  arguments: {object: noun_type_browser_tab},

  execute: function tab_execute(args) {
    let tab = args.object.data;
    chrome.tabs.update(tab.id, {active: true});
  },

  preview: function tab_preview(pblock, args) {
    var tabName = args.object.text;
    if (tabName)
      pblock.innerHTML = `Changes to &lt;strong&gt;${tabName}&lt;/strong&gt; tab.`;
    else
      pblock.innerHTML = "Switch to a tab by name.";
  }
});
</pre>
            </div>
            <h1 class="section-heading">
                <div class="mw-ui-icon mw-ui-icon-element indicator"></div>
                <span class="mw-headline" id="Development_Hints">Development Hints</span></h1>
            <div class="mf-section-5">
                <p>You now know all you need to know to get started developing useful iShell commands of your own.
                </p>
                <p>Here are some miscellaneous tips that didn't fit elsewhere on this page, that may make development
                    easier
                    for you.
                </p>
            </div>
                <h2 class="in-block"><span class="mw-headline" id="Running_on_page_load.2C_iShell_load_and_startup"
                >Running on iShell load and when iShell popup is shown</span>
                </h2>
                <p>There are two additional command properties may be set in cmdAPI.createCommand for that purposes:
                <ul>
                    <li>load - a function, called exactly once when the iShell is loaded.</li>
                    <li>init - a function, called each time iShell popup is shown with the popup document
                        as the parameter. Any document-wide CSS/script injections should be performed here.
                    </li>
            </ul></p>
                <h2 class="in-block"><span class="mw-headline" id="Persistent_Storage">Persistent Storage</span></h2>
                <p>Some commands may want to store data that persist even after closing Firefox.
                    Meet the <code>Bin</code> interface:
                </p>
                <pre>

let gId = 42; // used to avoid needless preview updates when typing
cmdAPI.createCommand({
    name: "memo",
    uuid: "FA6A3460-E825-4CFA-A24F-5908131D29FD",
    description: "Lets you jot a memo for the page.",
    author: "satyr",
    argument: noun_arb_text,
    execute: function({object: {html}}, Bin) {
        let href = cmdAPI.getLocation();
        let list = Bin.href() || [];
        list.push(html);
        Bin.href(list);
        gId = +new Date;
    },
    preview: function(pb, _, Bin) {
        let href = cmdAPI.getLocation();
        let list = Bin.href();
        if (!list) {
            pb.innerHTML =
                `No memos taken for: &lt;small&gt;&lt;code&gt;${href}&lt;/code&gt;&lt;/small&gt;`;
            return;
        }
        if ($("ol[data-id='" + gId + "']").length > 0) return;
        let ol = cmdAPI.previewList(pb, list, function deleteMemo(i, ev) {
            $(ev.target).closest("li").slideUp();
            list.splice(i, 1);
            Bin.href(list.length ? list : null);
            gId = +new Date;
        });
        ol.setAttribute("data-id", gId);
    },
});

</pre>
<hr>
                <div id="content" class="mw-body"><p>Authors: Aza Raskin, Blair McBride, Abimanyu Raja, Jono DiCarlo, Atul
                    Varma, Gerrard Christensen</p>
</body>
</html>